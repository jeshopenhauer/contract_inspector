"""
Creador de Reportes para Inspector de Contratos

Este m칩dulo contiene funciones para generar reportes a partir de archivos PDF de contratos.
Analiza el contenido del contrato y genera estad칤sticas y an치lisis t칠rmicos.
"""

import os
import json
import sys
import time
from pathlib import Path

# Configurar la importaci칩n para que funcione tan                try:
                    with open(template_article_path, 'r', encoding='utf-8') as f:
                        content = f.read()
                        html.append(f'<div class="content-container">')
                        html.append('<button class="copy-button" onclick="copyToClipboard(this)" title="Copiar al portapapeles"><i class="copy-icon">游늶</i></button>')
                        html.append('<pre class="article-content">')
                        html.append(content)
                        html.append('</pre>')
                        html.append('</div>')
                except Exception as e:
                    html.append(f'<p class="error">Error al leer el archivo: {str(e)}</p>')
                html.append('</details>') se ejecuta directamente como cuando se importa
current_dir = os.path.dirname(os.path.abspath(__file__))
sys.path.append(os.path.dirname(current_dir))  # A침adir el directorio padre al path

# Importar funciones necesarias de otros m칩dulos
try:
    # Intenta primero importaci칩n absoluta (cuando se ejecuta directamente)
    from inspector_functions.pdf_to_txt_pdfminer import convert_pdf_to_text
    from inspector_functions.txt_to_txt_splitter import split_contract_text
    from inspector_functions.txt_cleaner import standardize_page_breaks
except ImportError:
    # Si falla, usa importaci칩n relativa (cuando se importa como m칩dulo)
    from .pdf_to_txt_pdfminer import convert_pdf_to_text
    from .txt_to_txt_splitter import split_contract_text
    from .txt_cleaner import standardize_page_breaks

import inspector_functions.inspector_statistics as statistics
import inspector_functions.inspector_thermodynamics as thermodynamics

def create_report(input_pdf="input.pdf", output_dir="output_split"):
    """
    Crea un reporte completo del an치lisis de un contrato.
    
    Args:
        input_pdf (str): Ruta al archivo PDF del contrato
        output_dir (str): Directorio donde guardar los archivos divididos
        
    Returns:
        dict: Un diccionario con los resultados del an치lisis para ser entregado al cliente
    """
    report = {
        "timestamp": time.time(),
        "date": time.strftime("%Y-%m-%d %H:%M:%S"),
        "input_file": os.path.basename(input_pdf),
        "status": "processing",
        "statistics": {},
        "paragraph_analysis": {},
        "warnings": [],
        "errors": []
    }
    
    try:
        print(f"[DEBUG] create_report: Iniciando proceso para archivo {input_pdf}")
        print(f"[DEBUG] create_report: Directorio de salida: {output_dir}")
        
        # Paso 1: Convertir PDF a texto
        print(f"[INFO] create_report: PASO 1 - Convirtiendo PDF a texto")
        output_txt = os.path.join(os.path.dirname(os.path.dirname(os.path.abspath(__file__))), "output.txt")
        
        print(f"[DEBUG] create_report: La ruta del archivo de salida ser치 {output_txt}")
        print(f"[DEBUG] create_report: Verificando existencia de {input_pdf}")
        if os.path.exists(input_pdf):
            print(f"[DEBUG] create_report: El archivo {input_pdf} existe y tiene {os.path.getsize(input_pdf)} bytes")
        else:
            print(f"[ERROR] create_report: El archivo {input_pdf} no existe")
            
        text_content = convert_pdf_to_text(input_pdf)
        if not text_content:
            error_msg = "No se pudo extraer texto del PDF"
            print(f"[ERROR] create_report: {error_msg}")
            report["errors"].append(error_msg)
            report["status"] = "error"
            return report
            
        # Guardar el texto extra칤do
        print(f"[DEBUG] create_report: Guardando {len(text_content)} caracteres en {output_txt}")
        try:
            with open(output_txt, 'w', encoding='utf-8') as f:
                f.write(text_content)
            print(f"[INFO] create_report: Texto guardado exitosamente en {output_txt}")
        except Exception as e:
            print(f"[ERROR] create_report: Error al guardar el texto: {str(e)}")
            report["errors"].append(f"Error al guardar el texto: {str(e)}")
            
        print(f"[INFO] create_report: PASO 1 completado")
        
        # Paso 2: Dividir el texto en secciones
        print(f"[INFO] create_report: PASO 2 - Dividiendo texto en secciones")
        
        # Crear directorio de salida si no existe
        print(f"[DEBUG] create_report: Creando directorio de salida {output_dir} si no existe")
        os.makedirs(output_dir, exist_ok=True)
        
        try:
            print(f"[DEBUG] create_report: Verificando existencia del archivo de texto {output_txt}")
            if os.path.exists(output_txt):
                print(f"[DEBUG] create_report: El archivo {output_txt} existe y tiene {os.path.getsize(output_txt)} bytes")
            else:
                print(f"[ERROR] create_report: El archivo {output_txt} no existe")
                raise FileNotFoundError(f"Archivo no encontrado: {output_txt}")
                
            print(f"[DEBUG] create_report: Iniciando divisi칩n del texto en {output_dir}")
            split_results = split_contract_text(output_txt, output_dir)
            
            num_files = len(split_results) if isinstance(split_results, dict) else 0
            print(f"[INFO] create_report: Se crearon {num_files} archivos en {output_dir}")
            
            # Listar los archivos creados
            print(f"[DEBUG] create_report: Archivos creados:")
            for section, path in (split_results.items() if isinstance(split_results, dict) else []):
                print(f"[DEBUG] create_report:   - {section}: {path}")
                
            # Aplicar limpieza a cada archivo generado
            print(f"[INFO] create_report: Aplicando limpieza a los archivos generados")
            for section, path in (split_results.items() if isinstance(split_results, dict) else []):
                try:
                    # Limpiar y guardar con el mismo nombre para mantener la estructura
                    print(f"[DEBUG] create_report: Limpiando archivo {path}")
                    standardize_page_breaks(path, path)
                    print(f"[DEBUG] create_report: Archivo {path} limpiado correctamente")
                except Exception as e:
                    print(f"[WARNING] create_report: Error al limpiar archivo {path}: {str(e)}")
                    # Continuamos con el siguiente archivo si hay error en uno
        except Exception as e:
            import traceback
            error_msg = f"Error al dividir el texto: {str(e)}"
            print(f"[ERROR] create_report: {error_msg}")
            print(f"[DEBUG] {traceback.format_exc()}")
            report["errors"].append(error_msg)
            report["status"] = "error"
            return report
            
        print(f"[INFO] create_report: PASO 2 completado")
        
        # Paso 3: Analizar estad칤sticas
        
        try:
            # Obtener la ruta al directorio de plantillas
            base_dir = Path(__file__).parent.parent
            template_dir = os.path.join(base_dir, "template")
            
            # Analizar estad칤sticas
            stats_results = statistics.compare_files_with_templates(output_dir, template_dir)
            
            # Convertir resultados a un formato m치s adecuado para JSON
            for article, data in stats_results.items():
                if 'ratios' in data:
                    # Convertir los valores de ratio a cadenas de texto para JSON
                    stats_results[article]['ratios'] = {
                        k: str(v) for k, v in data['ratios'].items()
                    }
            
            report["statistics"] = stats_results
            
        except Exception as e:
            report["warnings"].append(f"Error al analizar estad칤sticas: {str(e)}")
        
        # Paso 4: Analizar p치rrafos
        
        try:
            # Analizar p치rrafos
            para_results = thermodynamics.compare_paragraph_counts(output_dir, template_dir)
            
            # Convertir resultados a un formato m치s adecuado para JSON
            formatted_para_results = {}
            for section, data in para_results.items():
                if 'error' not in data:
                    formatted_para_results[section] = {
                        'output_paragraphs': data['output_paragraphs'],
                        'template_paragraphs': data['template_paragraphs'],
                        'ratio': data['ratio']
                    }
                else:
                    formatted_para_results[section] = {'error': data['error']}
            
            report["paragraph_analysis"] = formatted_para_results
            
        except Exception as e:
            report["warnings"].append(f"Error al analizar p치rrafos: {str(e)}")
        
        # Finalizar reporte
        report["status"] = "complete" if not report["errors"] else "error"
        
        # Guardar el reporte en un archivo JSON para referencia
        report_file = os.path.join(base_dir, "contract_report.json")
        with open(report_file, 'w', encoding='utf-8') as f:
            json.dump(report, f, indent=2, ensure_ascii=False)
            
        return report
        
    except Exception as e:
        report["status"] = "error"
        report["errors"].append(f"Error general: {str(e)}")
        return report


def get_report_html(report, output_dir="output_split"):
    """
    Convierte el reporte en formato HTML para mostrarlo en la p치gina web.
    
    Args:
        report (dict): El reporte generado por create_report()
        output_dir (str): Directorio donde se encuentran los archivos divididos
        
    Returns:
        str: HTML formateado del reporte
    """
    html = []
    html.append('<div class="report-container">')
    
    # Encabezado del reporte
    html.append('<div class="report-header">')
    html.append(f'<h2>Reporte de An치lisis: {report["input_file"]}</h2>')
    html.append(f'<p>Generado el: {report["date"]}</p>')
    html.append(f'<p class="status-{report["status"]}">Estado: {report["status"].upper()}</p>')
    html.append('</div>')
    
    # Quitar el resumen de pasos (simplificaci칩n solicitada)
    
    # Si hay errores, mostrarlos
    if report["errors"]:
        html.append('<div class="report-errors">')
        html.append('<h3>Errores encontrados:</h3>')
        html.append('<ul>')
        for error in report["errors"]:
            html.append(f'<li>{error}</li>')
        html.append('</ul>')
        html.append('</div>')
    
    # Si hay advertencias, mostrarlas
    if report["warnings"]:
        html.append('<div class="report-warnings">')
        html.append('<h3>Advertencias:</h3>')
        html.append('<ul>')
        for warning in report["warnings"]:
            html.append(f'<li>{warning}</li>')
        html.append('</ul>')
        html.append('</div>')
    
    # An치lisis combinado (estad칤sticas y p치rrafos)
    if report["statistics"] and report["paragraph_analysis"]:
        html.append('<div class="report-combined-analysis">')
        html.append('<h3>An치lisis Completo por Secci칩n</h3>')
        
        # Crear tabla en formato ASCII usando tabulate
        from tabulate import tabulate
        
        # Preparar datos para la tabla combinada
        table_data = []
        headers = ['Art.', 'palabras', 'puntos.', 'comas.', 's', 'a', 'e', 'i', 'o', 'u', 
                   'P치rrafos (Contrato)', 'P치rrafos (Plantilla)', 'Relaci칩n']
        
        # Solo incluir los art칤culos (1-15), omitir title, between, and
        for i in range(1, 16):
            article_key = f'article_{i}'
            row = [i]
            
            # A침adir estad칤sticas
            if article_key in report["statistics"]:
                data = report["statistics"][article_key]
                if 'ratios' in data:
                    output_stats = data['output_stats']
                    template_stats = data['template_stats']
                    
                    for key in ['word_count', 'period_count', 'comma_count', 's_count', 
                               'a_count', 'e_count', 'i_count', 'o_count', 'u_count']:
                        # Formato como fracci칩n output/template
                        if template_stats[key] == 0:
                            if output_stats[key] > 0:
                                row.append('inf')
                            else:
                                row.append('1')
                        else:
                            row.append(f"{output_stats[key]}/{template_stats[key]}")
                else:
                    row.extend(['ERROR'] * 9)
            else:
                row.extend(['-'] * 9)
            
            # A침adir an치lisis de p치rrafos
            if article_key in report["paragraph_analysis"]:
                data = report["paragraph_analysis"][article_key]
                if 'error' not in data:
                    output_count = data['output_paragraphs']
                    template_count = data['template_paragraphs']
                    ratio = data['ratio']
                    row.extend([output_count, template_count, ratio])
                else:
                    row.extend([f"ERROR", "-", "-"])
            else:
                row.extend(['-', '-', '-'])
            
            table_data.append(row)
        
        # Generar tabla ASCII
        ascii_table = tabulate(table_data, headers=headers, tablefmt="grid")
        
        # A침adir la tabla ASCII al HTML como texto preformateado
        html.append('<pre class="ascii-table">')
        html.append(ascii_table)
        html.append('</pre>')
        
        html.append('</div>')
        
        # A침adir secci칩n de comparaci칩n visual con desplegables
        html.append('<div class="visual-comparison">')
        html.append('<h3>Comparaci칩n Visual de Art칤culos</h3>')
        
        # Obtener la ruta al directorio de plantillas
        base_dir = Path(__file__).parent.parent
        template_dir = os.path.join(base_dir, "template")
        
        # Crear desplegables para cada art칤culo, alternando contrato y plantilla
        for i in range(1, 16):
            article_key = f'article_{i}'
            
            # Ruta al archivo de salida del art칤culo
            output_article_path = os.path.join(output_dir, f'output_{article_key}.txt')
            # Ruta al archivo de plantilla del art칤culo
            template_article_path = os.path.join(template_dir, f'template_{article_key}.txt')
            
            # Verificar si existen los archivos
            if os.path.exists(output_article_path):
                # A침adir desplegable para el art칤culo del contrato
                html.append(f'<details class="article-comparison card">')
                html.append(f'<summary>output_{article_key}</summary>')
                try:
                    with open(output_article_path, 'r', encoding='utf-8') as f:
                        content = f.read()
                        html.append(f'<div class="content-container">')
                        html.append('<button class="copy-button" onclick="copyToClipboard(this)" title="Copiar al portapapeles"><i class="copy-icon">游늶</i></button>')
                        html.append('<pre class="article-content">')
                        html.append(content)
                        html.append('</pre>')
                        html.append('</div>')
                except Exception as e:
                    html.append(f'<p class="error">Error al leer el archivo: {str(e)}</p>')
                html.append('</details>')
            
            # Verificar si existe el archivo de plantilla
            if os.path.exists(template_article_path):
                # A침adir desplegable para el art칤culo de la plantilla
                html.append(f'<details class="template-comparison card">')
                html.append(f'<summary>template_{article_key}</summary>')
                try:
                    with open(template_article_path, 'r', encoding='utf-8') as f:
                        content = f.read()
                        html.append('<pre class="template-content">')
                        html.append(content)
                        html.append('</pre>')
                except Exception as e:
                    html.append(f'<p class="error">Error al leer el archivo: {str(e)}</p>')
                html.append('</details>')
        
        html.append('</div>')
    
    html.append('</div>')  # Cierra report-container
    
    return '\n'.join(html)


# Funci칩n principal para ejecutar desde la l칤nea de comandos
if __name__ == "__main__":
    input_pdf = "input.pdf"
    output_dir = "output_split"
    
    # Permitir especificar archivo de entrada
    if len(sys.argv) > 1:
        input_pdf = sys.argv[1]
    
    # Permitir especificar directorio de salida
    if len(sys.argv) > 2:
        output_dir = sys.argv[2]
    
    print(f"Generando reporte para {input_pdf}...")
    report = create_report(input_pdf, output_dir)
    
    if report["status"] == "complete":
        print("Reporte generado con 칠xito")
    else:
        print(f"Error al generar reporte: {report['errors']}")




